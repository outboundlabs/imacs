{# C# orchestrator template #}
{% if provenance %}
// GENERATED FROM: {{ id }}.yaml
// GENERATED: {{ generated_at }}
// DO NOT EDIT - regenerate from spec

{% endif %}
using System;
using System.Collections.Generic;
using Newtonsoft.Json.Linq;

namespace {{ namespace | default("Generated") }}
{
    public class {{ id_pascal }}Input
    {
{% for input in inputs %}
        public {{ input.csharp_type }} {{ input.name_pascal }} { get; set; }
{% endfor %}
    }

    public class {{ id_pascal }}Output
    {
{% for output in outputs %}
        public {{ output.csharp_type }} {{ output.name_pascal }} { get; set; }
{% endfor %}
    }

    internal class {{ id_pascal }}Context
    {
{% for step in steps %}
{% if step.is_call %}
        public JToken {{ step.id }};
{% endif %}
{% endfor %}
    }

    public class {{ id_pascal }}Exception : Exception
    {
        public string Step { get; }
        public string ErrorType { get; }

        public {{ id_pascal }}Exception(string step, string errorType, string message)
            : base(message)
        {
            Step = step;
            ErrorType = errorType;
        }
    }

    public static class {{ id_pascal }}Orchestrator
    {
        public static {{ id_pascal }}Output Execute({{ id_pascal }}Input input)
        {
            var ctx = new {{ id_pascal }}Context();
{% for step in steps %}
{% if step.is_call %}
{% if step.condition_csharp %}

            // Step: {{ step.id }} (call {{ step.spec_id }}) - conditional
            if ({{ step.condition_csharp }})
            {
{% endif %}
            // Step: {{ step.id }} (call {{ step.spec_id }})
            var {{ step.id }}Input = new {{ step.spec_id | pascal_case }}Input
            {
{% for mapping in step.input_mappings %}
                {{ mapping.spec_input_name | pascal_case }} = {{ mapping.expr_csharp }}{% if not loop.last %},{% endif %}
{% endfor %}
            };
            var {{ step.id }}Result = {{ step.spec_id | pascal_case }}.Evaluate({{ step.id }}Input);
            ctx.{{ step.id }} = JToken.FromObject({{ step.id }}Result);
{% if step.condition_csharp %}
            }
{% endif %}
{% elif step.is_gate %}

            // Gate: {{ step.id }}
            if (!({{ step.condition_csharp }}))
            {
                throw new {{ id_pascal }}Exception(
                    "{{ step.id }}",
                    "gate_failed",
                    "Gate condition failed: {{ step.condition }}"
                );
            }
{% elif step.is_compute %}

            // Compute: {{ step.id }}
            // TODO: Implement compute step
{% elif step.is_branch %}

            // Branch: {{ step.id }}
            if ({{ step.condition_csharp }})
            {
                // TODO: true branch
            }
            else
            {
                // TODO: false branch
            }
{% elif step.is_loop %}

            // Loop: {{ step.id }}
            // TODO: Implement loop
{% endif %}
{% endfor %}

            return new {{ id_pascal }}Output
            {
{% for output in outputs %}
                {{ output.name_pascal }} = default,  // TODO: map output from context
{% endfor %}
            };
        }
    }
}
