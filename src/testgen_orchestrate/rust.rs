//! Rust orchestrator test generation

use crate::orchestrate::*;
use crate::spec::Spec;
use std::collections::HashMap;

use super::{find_connections, to_pascal};

pub fn generate_integration_tests(orch: &Orchestrator, _specs: &HashMap<String, Spec>) -> String {
    let mut out = String::new();

    out.push_str(&format!(
        "// Integration tests for orchestrator: {}\n// Generated by IMACS\n\n#[cfg(test)]\nmod {}_integration_tests {{\n    use super::*;\n\n",
        orch.id, orch.id
    ));

    // Happy path test
    out.push_str(&format!(
        "    #[test]\n    fn test_{}_happy_path() {{\n        let input = {}Input {{\n{}\n        }};\n\n        let result = {}(input);\n        assert!(result.is_ok());\n    }}\n\n",
        orch.id,
        to_pascal(&orch.id),
        orch.inputs.iter().map(|i| format!("            {}: todo!(),", i.name)).collect::<Vec<_>>().join("\n"),
        orch.id
    ));

    // Branch tests
    for step in &orch.chain {
        if let ChainStep::Branch(branch) = step {
            for case_name in branch.cases.keys() {
                out.push_str(&format!(
                    "    #[test]\n    fn test_{}_branch_{}_case_{}() {{\n        let input = {}Input {{\n{}\n        }};\n        let result = {}(input);\n        assert!(result.is_ok());\n    }}\n\n",
                    orch.id, branch.id, case_name, to_pascal(&orch.id),
                    orch.inputs.iter().map(|i| format!("            {}: todo!(),", i.name)).collect::<Vec<_>>().join("\n"),
                    orch.id
                ));
            }
        }
    }

    // Gate tests
    for step in &orch.chain {
        if let ChainStep::Gate(gate) = step {
            out.push_str(&format!(
                "    #[test]\n    fn test_{}_gate_{}_fails() {{\n        let input = {}Input {{\n{}\n        }};\n        let result = {}(input);\n        assert!(result.is_err());\n    }}\n\n",
                orch.id, gate.id, to_pascal(&orch.id),
                orch.inputs.iter().map(|i| format!("            {}: todo!(),", i.name)).collect::<Vec<_>>().join("\n"),
                orch.id
            ));
        }
    }

    out.push_str("}\n");
    out
}

pub fn generate_contract_tests(orch: &Orchestrator, specs: &HashMap<String, Spec>) -> String {
    let mut out = String::new();

    out.push_str(&format!(
        "// Contract tests for orchestrator: {}\n\n#[cfg(test)]\nmod {}_contract_tests {{\n    use super::*;\n\n",
        orch.id, orch.id
    ));

    let connections = find_connections(&orch.chain);
    for (from_spec, to_spec, _) in connections {
        if specs.contains_key(&from_spec) && specs.contains_key(&to_spec) {
            out.push_str(&format!(
                "    #[test]\n    fn test_contract_{}_to_{}() {{\n        // Verify {} output is compatible with {} input\n    }}\n\n",
                from_spec, to_spec, from_spec, to_spec
            ));
        }
    }

    out.push_str("}\n");
    out
}
