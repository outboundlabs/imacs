//! C# orchestrator test generation

use crate::orchestrate::*;
use crate::spec::Spec;
use std::collections::HashMap;

use super::{find_connections, to_pascal};

pub fn generate_integration_tests(orch: &Orchestrator, _specs: &HashMap<String, Spec>) -> String {
    let mut out = String::new();
    let class_name = to_pascal(&orch.id);

    out.push_str(&format!(
        "// Integration tests for orchestrator: {}\n// Generated by IMACS\n\nusing Xunit;\n\nnamespace Tests\n{{\n    public class {}IntegrationTests\n    {{\n",
        orch.id, class_name
    ));

    // Happy path test
    out.push_str(&format!(
        "        [Fact]\n        public async Task Test{}_HappyPath()\n        {{\n            var input = new {}Input\n            {{\n{}\n            }};\n\n            var result = await {}.Evaluate(input);\n            Assert.NotNull(result);\n        }}\n\n",
        class_name,
        class_name,
        orch.inputs.iter().map(|i| format!("                {} = default,", to_pascal(&i.name))).collect::<Vec<_>>().join("\n"),
        class_name
    ));

    // Branch tests
    for step in &orch.chain {
        if let ChainStep::Branch(branch) = step {
            for case_name in branch.cases.keys() {
                out.push_str(&format!(
                    "        [Fact]\n        public async Task Test{}_Branch{}_Case{}()\n        {{\n            var input = new {}Input\n            {{\n{}\n            }};\n            var result = await {}.Evaluate(input);\n            Assert.NotNull(result);\n        }}\n\n",
                    class_name, to_pascal(&branch.id), to_pascal(case_name), class_name,
                    orch.inputs.iter().map(|i| format!("                {} = default,", to_pascal(&i.name))).collect::<Vec<_>>().join("\n"),
                    class_name
                ));
            }
        }
    }

    // Gate tests
    for step in &orch.chain {
        if let ChainStep::Gate(gate) = step {
            out.push_str(&format!(
                "        [Fact]\n        public async Task Test{}_Gate{}_Fails()\n        {{\n            var input = new {}Input\n            {{\n{}\n            }};\n            await Assert.ThrowsAsync<InvalidOperationException>(() => {}.Evaluate(input));\n        }}\n\n",
                class_name, to_pascal(&gate.id), class_name,
                orch.inputs.iter().map(|i| format!("                {} = default,", to_pascal(&i.name))).collect::<Vec<_>>().join("\n"),
                class_name
            ));
        }
    }

    out.push_str("    }\n}\n");
    out
}

pub fn generate_contract_tests(orch: &Orchestrator, specs: &HashMap<String, Spec>) -> String {
    let mut out = String::new();
    let class_name = to_pascal(&orch.id);

    out.push_str(&format!(
        "// Contract tests for orchestrator: {}\n\nusing Xunit;\n\nnamespace Tests\n{{\n    public class {}ContractTests\n    {{\n",
        orch.id, class_name
    ));

    let connections = find_connections(&orch.chain);
    for (from_spec, to_spec, _) in connections {
        if specs.contains_key(&from_spec) && specs.contains_key(&to_spec) {
            out.push_str(&format!(
                "        [Fact]\n        public void TestContract_{}_To_{}()\n        {{\n            // Verify {} output is compatible with {} input\n        }}\n\n",
                to_pascal(&from_spec), to_pascal(&to_spec), from_spec, to_spec
            ));
        }
    }

    out.push_str("    }\n}\n");
    out
}
