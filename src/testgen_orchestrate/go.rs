//! Go orchestrator test generation

use crate::orchestrate::*;
use crate::spec::Spec;
use std::collections::HashMap;

use super::{find_connections, to_pascal};

pub fn generate_integration_tests(orch: &Orchestrator, _specs: &HashMap<String, Spec>) -> String {
    let mut out = String::new();
    let func_name = to_pascal(&orch.id);

    out.push_str(&format!(
        "// Integration tests for orchestrator: {}\n// Generated by IMACS\n\npackage {}\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n",
        orch.id, orch.id
    ));

    // Happy path test
    out.push_str(&format!(
        "func Test{}_HappyPath(t *testing.T) {{\n\tinput := {}Input{{\n\t\t// TODO: Set input fields\n\t}}\n\n\tresult, err := {}(input)\n\tassert.NoError(t, err)\n\tassert.NotNil(t, result)\n}}\n\n",
        func_name, func_name, func_name
    ));

    // Branch tests
    for step in &orch.chain {
        if let ChainStep::Branch(branch) = step {
            for case_name in branch.cases.keys() {
                out.push_str(&format!(
                    "func Test{}_Branch{}_Case{}(t *testing.T) {{\n\tinput := {}Input{{}}\n\tresult, err := {}(input)\n\tassert.NoError(t, err)\n\tassert.NotNil(t, result)\n}}\n\n",
                    func_name, to_pascal(&branch.id), to_pascal(case_name), func_name, func_name
                ));
            }
        }
    }

    // Gate tests
    for step in &orch.chain {
        if let ChainStep::Gate(gate) = step {
            out.push_str(&format!(
                "func Test{}_Gate{}_Fails(t *testing.T) {{\n\tinput := {}Input{{}}\n\t_, err := {}(input)\n\tassert.Error(t, err)\n}}\n\n",
                func_name, to_pascal(&gate.id), func_name, func_name
            ));
        }
    }

    out
}

pub fn generate_contract_tests(orch: &Orchestrator, specs: &HashMap<String, Spec>) -> String {
    let mut out = String::new();
    let func_name = to_pascal(&orch.id);

    out.push_str(&format!(
        "// Contract tests for orchestrator: {}\n\npackage {}\n\nimport (\n\t\"testing\"\n)\n\n",
        orch.id, orch.id
    ));

    let connections = find_connections(&orch.chain);
    for (from_spec, to_spec, _) in &connections {
        if specs.contains_key(from_spec) && specs.contains_key(to_spec) {
            out.push_str(&format!(
                "func TestContract_{}_To_{}(t *testing.T) {{\n\t// Verify {} output is compatible with {} input\n}}\n\n",
                to_pascal(from_spec), to_pascal(to_spec), from_spec, to_spec
            ));
        }
    }

    // Add at least one test if no connections
    if connections.is_empty() {
        out.push_str(&format!(
            "func Test{}ContractInterfacesCompatible(t *testing.T) {{\n\t// Verify spec interfaces are compatible\n}}\n",
            func_name
        ));
    }

    out
}
